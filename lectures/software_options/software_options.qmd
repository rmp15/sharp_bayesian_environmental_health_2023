---
title: "Software Options for Bayesian Modelling"
subtitle: "Should we still use WinBugs?"
author:
 - name: "Theo Rashid"
   email: "theo.rashid15@imperial.ac.uk"
institute: "Imperial College London"
date: 2023-08-15
date-format: medium
title-slide-attributes:
  data-background-color: "#f3f4f4"
  data-background-image: "../../assets/bmeh_normal.png"
  data-background-size: 80%
  data-background-position: 60% 120%
format:
  revealjs:
    slide-number: true
    incremental: true
    chalkboard:
      buttons: false
      preview-links: auto
    logo: "../../assets/bmeh_normal.png"
    theme: [default, ../../assets/style.scss]
---

# What did people do before packages?

## They wrote their posterior probability density

$$
y_i \sim \alpha + \mathbf{x_i^\top} \mathbf{\beta} + \epsilon_i \\
\epsilon_i \sim \text{Normal}(0, \sigma) \\
\alpha \sim \text{Normal}(0, 10) \\
\mathbf{\beta} \sim \text{Normal}(0, 1) \\
\sigma \sim \text{Uniform}(0, 100)
$$

```{.python code-line-numbers="5-8"}
import numpy as np
from scipy.stats import norm
from scipy.special import logsumexp

def logpdf(params, data):
    log_prior = np.log(params)
    log_likelihood = norm(**params).logpdf(data)
    return logsumexp(log_prior + log_likelihood, axis=0)
```

## They wrote their own samplers

```{.python code-line-numbers="8-9"}
import numpy as np

def rw_metropolis_kernel(logpdf, data, position, log_prob):
    move_proposals = np.random.normal(0, 0.1, size=position.shape)
    proposal = position + move_proposals
    proposal_log_prob = logpdf(proposal, data)

    log_uniform = np.log(np.random.uniform(low=0, high=1))
    do_accept = log_uniform < proposal_log_prob - log_prob

    position = np.where(do_accept, proposal, position)
    log_prob = np.where(do_accept, proposal_log_prob, log_prob)
    return position, log_prob
```

## You are not Arianna Rosenbluth

- You will make a mistake.
- Why write code that people have written before?
- Do you enjoy calibrating samplers?

::: {.notes}
You will make a mistake.
People have done this before, and spent a lot more time doing this.
They write better inference algorithms than you.

It turns out that he and Arianna Rosenbluth (his wife) did most of the work. More specifically, he did the mathematical work, Arianna wrote the code that ran on the MANIAC, August Teller wrote an earlier version of the code, and Edward Teller gave some critical suggestions about the methodology. Finally, Nick Metropolis provided the computing time; as he was first author the method is therefore named after him. But perhaps a more appropriate name would have been the Rosenbluth algorithm.
:::

# Probabilistic programming languages

# "Monolithic"

::: {.notes}
Thomas Wiecki, PyMC dev
:::

# WinBUGS

## Write models in the BUGS language

```{.R}
model(
  # prior
  alpha ~ dnorm(0, pow(10, -2))
  sigma ~ dunif(0, 100)
  tau <- pow(sigma, -2) # precision
  for (k in 1:p) beta[k] ~ dnorm(0, 1)

  # likelihood
  for (i in 1:n) {
    y[i] ~ dnorm(mu[i], tau)
    mu[i] <- alpha + inprod(beta[1:p], x[i, 1:p])
  }
)
```

## Look at this <span style="color:pink;">thrilling</span> output.

![](assets/winbugs_screenshot.jpeg)

## Is WinBugs still good?^[No]

:::: {.columns}
::: {.column width="50%"}
::: {style="color: #58b364"}
- Point and click
- See your chains as they run
:::
:::

::: {.column width="50%"}
::: {style="color: #fc6161"}
- Slow
- Old
:::
:::

::::

- No

# Stan

## Model in Stan

```
data {
  int<lower=0> N;   // number of data items
  int<lower=0> P;   // number of predictors
  matrix[N, K] x;   // predictor matrix
  vector[N] y;      // outcome vector
}
parameters {
  real alpha;           // intercept
  vector[P] beta;       // coefficients for predictors
  real<lower=0> sigma;  // error scale
}
transformed parameters {
  vector[N] mu;
  mu = alpha + X * beta;
}
model {
  alpha ~ normal(0., 10.);
  beta ~ normal(0., 1.);
  sigma ~ uniform(0., 100.);
  y ~ normal(mu, sigma);  // likelihood
}
```

::: aside
Stan, not STAN
:::

::: {.notes}
Stanislaw Ulam is probably best known for realising that electronic computers made it practical to apply statistical methods to functions without known solutions, and as computers have developed, the Monte Carlo method has become a common and standard approach to many problems.
:::

## The granddaddy of PPLs

:::: {.columns}

::: {.column width="50%"}
::: {style="color: #58b364"}
- The statistician's choice
- Reliable, battle-tested samplers (including NUTS)
- Interface with `python`, `R` or `Julia`
:::
:::

::: {.column width="50%"}
::: {style="color: #fc6161"}
- Difficult to extend
- Writing things like `int<lower=0> N`
:::
:::

::::

- Using `brms` or `rstanarm`, you can write models like base `R` (like `y ~ 1 + x`) and the inference is done in Stan.

# nimble

## nimble model is like WinBUGS, but more flexible

```{.R}
model(
  # prior
  alpha ~ dnorm(0, sd = 10)
  sigma ~ dunif(0, 100)
  beta[1:k] ~ dnorm(0, 1)

  # likelihood
  for (i in 1:n) {
    y[i] ~ dnorm(mu[i], tau)
    mu[i] <- alpha + (beta[1:p] %*% x[i, 1:p])[1,1]
  }
)
```

## I like nimble, but

:::: {.columns}

::: {.column width="50%"}
::: {style="color: #58b364"}
- Compiles `R` to `C++` for speed and scalability
- Automatically finds conjugate relationships
- Can pick a different sampler for each parameter
:::
:::

::: {.column width="50%"}
::: {style="color: #fc6161"}
- If the sampler is not conjugate, it can mix poorly
:::
:::

::::

## Ranking these PPLs^[Entirely subjective]
Usability:

- How easy is it to fit a model?
- How easy is it to run the model?
- How good is the documentation?
- Does it have everything I need?
- How good is the performance?

## Ranking these PPLs^[Entirely subjective]
Extensibility:

- If it can't do something, how easily can I make it do that?
- How modular is it? Can other packages work with it?

## Ranking these PPLs^[Entirely subjective]
Where does each PPL stand on the extensibility-usability scale

# Decoupled

## Decoupled

Separate the model from the inference.
Tensor libraries to do the maths
PyTorch, tensorflow, jax, aesara etc

## tensorflow probability

```{.python}
def model(np, x):
    def joint_dist():
        alpha = yield tfd.Normal(loc=0.0, scale=10.0)
        sigma = yield tfd.Uniform(low=0.0, high=100.0)

        beta = yield tfd.Normal(loc=tf.zeros(np), scale=1.0)

        mu = alpha + tf.linalg.matmul(x, beta)

        yield tfd.Normal(loc=mu, scale=sigma)

    return tfd.JointDistributionCoroutineAutoBatched(joint_dist)
```

This is trash.

Don't use it.

## PyMC

```{.python}
with pm.Model() as model:
    alpha = pm.Normal("alpha", 0.0, sigma=10.0)
    sigma = pm.Uniform("sigma", low=0.0, high=100.0)
    beta = pm.Normal("beta", 0, sigma=1.0, shape=(np,))

    mu = alpha + pt.matmul(x, beta)

    likelihood = pm.Normal("y", mu=mu, sigma=sigma, observed=y)
```

Big community

## numpyro

```{.python}
def model(np, x, y=None):
    alpha = numpyro.sample("alpha", dist.Normal(0.0, 10.0))
    sigma = numpyro.sample("sigma", dist.Uniform(0.0, 100.0))

    with numpyro.plate("plate_predictors", np):
        beta = numpyro.sample("beta", dist.Normal(0.0, 1.0))

    mu = alpha + jnp.matmul(x, beta)

    with numpyro.plate("data", len(x)):
        numpyro.sample("y", dist.Normal(mu, sigma), obs=y)
```

- Really quick
- Runs on GPU
- My favourite

::: aside
There is a related package called Pyro with a PyTorch backend, but numpyro's `jax` backend is better for sampling.
:::

## Other packages

Other such as `JAGS`, `greta`, `beanmachine`, `Turing.jl`

## blackjax

## Maybe in a bit

# And what about the samples

Yeah, `posterior` for `R` and `ArviZ` for `python`.

# Is sampling the only way?

## Variational inference

Turn sampling into an optimisation problem
Optimise the ELBO

- No guarantees

## INLA

- Really quick
- Only used by 3 people, 2 of whom are here today
